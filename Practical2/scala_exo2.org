#+Title: Inheritance, overriding and dynamic binding
#+LANGUAGE: nil
#+OPTIONS:  H:3 skip:nil num:t toc:nil 
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [11pt]
#+LaTeX_HEADER: \usepackage{../tex/ensrennes}
#+LATEX_HEADER: \usepackage{xcolor,float,array}
#+LATEX_HEADER: \usepackage{tikz}\usetikzlibrary{arrows}
#+LATEX_HEADER: \usepackage[american inductor]{circuitikz}
#+LATEX_HEADER: \usepackage{../tex/pgf-umlcd}
#+LATEX_HEADER: \usepackage{../tex/pgf-crccards}
# non #+LATEX_HEADER: \usepackage{../tex/starsection}

#+LATEX_HEADER: \hypersetup{urlcolor={blue},colorlinks}
#+LATEX_HEADER: \usepackage{fullpage}
#+LATEX_HEADER: \renewcommand{\maketitle}{
#+LATEX_HEADER:   \noindent\null\hfill\begin{minipage}{.85\linewidth} 
#+LATEX_HEADER:   \centering
#+LATEX_HEADER:   \textbf{\Large Inheritance, Overriding and Dynamic Binding}\par\medskip%
#+LATEX_HEADER:     OOP in Scala\par
#+LATEX_HEADER:    {\footnotesize 2016}
#+LATEX_HEADER:   \end{minipage}\hfill\null
#+LATEX_HEADER: }
#+LATEX_HEADER: \thispagestyle{empty}

#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \captionsetup{labelformat=empty,textfont=bf}
  
* OOP Design
This exercise introduce a systematic method that can be used to design
object systems: CRC cards (\emph{Class, Responsibilities,
Collaborators})[fn:: K. Beck and W. Cunningham. A Laboratory for
Teaching Object-Oriented Thinking, in Proceedings of
OOPSLA'89. pp.~1--6, 1989. ACM Press. 
\url{http://doi.acm.org/10.1145/74877.74879}]. Each card
describes a class of objects, abstracting away its implementation.
Each such description has three components:

- *Name of class:* This name creates a vocabulary between the conceptors 
  of an application. It must thus be wisely chosen, to correctly
  describe the class purpose. It must be as indicative as possible,
  since it will be used in a much wider scope.
- *Responsibilities:* They identify the problems solved by this
  class. To define them, ask yourself the following questions: /what
  should my object *know*?/ and /what should my object *do* in my
  application?/ \par The first category of responsibilities (know
  things) encompasses mainly the values it should save while the
  second category of responsibility (do things) encompass the
  following:
  - do a given computation ;
  - modify its internal state in some way;
  - create and initialize other objects ;
  - control and coordinate the activity of other objects.
- *Collaborators:* The names of classes with which this class must
  cooperate to achieve its responsibilities. So they are the classes
  to which this one will send messages (call methods) or from which it
  will receive messages.

Here is an example CRC card, form a simple dice.
#+BEGIN_LaTeX
\begin{CRC}{}{Dice}
  \responsability{Save the value (a char) of each of the 6 sides}
  \responsability{Save the currently visible side}
  \responsability{Allow to retrieve the visible side}
  \responsability{Allow to cast another dice (the visible side is updated)}

	   \collaborator{java.util.Random}
	\end{CRC}
#+END_LaTeX

\begin{Exercice}
  L'objectif de cet exercice est de déterminer les classes nécessaires à la
  réalisation d'un interpréteur rudimentaire LOGO.

  Le langage LOGO a été crée au dans les années 1960 au Massachusetts Institute
  of Technology (MIT) par Wally Feurzeig et Seymour Papert. C'est un bon
  langage d'initiation à la programmation en particulier pour les enfants grâce
  au côté ludique de la tortue graphique. La tortue graphique peut effectuer
  les actions suivantes : avancer de $N$ pixels, tourner à droite de $N$
  degrés, tourner à gauche de $N$ degrés, reculer de $N$ pixels, se cacher, se
  montrer, lever le crayon, poser le crayon, changer la couleur du crayon.

  La classe \texttt{tortue.Screen} représente l'écran graphique de notre
  application. L'interface publique offerte par cette classe est la suivante : 
\small
\begin{Verbatim}
class Screen {
  def Screen(width:Int, height:Int) 
  def setForegroundColor(c:Color) :Unit
  def drawLine(xA:Int, yA:Int, xB:Int, yB:Int) ;
  def fillRectangle(xA:Int, yA:Int, xB:Int, yB:Int) ;
  def setBackgroundColor(c:Color) ;
  def clear() :Unit
}
\end{Verbatim}
\normalsize

\begin{Question}
Réaliser la carte CRC correspondant à la classe \texttt{tortue.Screen}.
\end{Question}

\begin{Reponse}
	\begin{CRC}{}{tortue.Screen}
	    \responsability{Permet de définir la couleur avec laquelle on dessine}
	    \responsability{Permet de dessiner une ligne à l'écran}
	    \responsability{Permet de définir la couleur de fond d'écran}
	    \responsability{Offre la possibilité d'effacer l'écran}
    \end{CRC}
\end{Reponse}


\begin{Question}
  Réaliser la carte CRC de la classe \texttt{tortue.Tortoise}, modélisant la tortue.
\end{Question}

\begin{Reponse}
	\begin{CRC}{}{tortue.Tortoise}
	    \responsability{Permet de définir la couleur du crayon}
	    \responsability{Permet de poser/lever le crayon}
	    \responsability{Permet de déplacer la tortue (avancer, reculer)}
	    \responsability{Permet de faire tourner la tortue (droite, gauche)}
	    \responsability{Permet de cacher/montrer la tortue}
	    \responsability{Permet de savoir si la tortue est visible}
	    \responsability{Conserve la position actuelle de la tortue (x,y)}

        \collaborator{tortue.Screen}
    \end{CRC}	
\end{Reponse}

\begin{Question}
  \`A partir de la carte CRC déterminer une interface publique possible pour la
  classe \texttt{tortue.Tortoise}.
\end{Question}

\begin{Reponse}
\small
\begin{Verbatim}
public Tortoise() ;
public Tortoise(int initialX, int initialY) ;
public void forward(int pixelCount) ;
public void backward(int pixelCount) ;
public void turnLeft(int angleInDegree) ;
public void turnRight(int angleInDegree) ;
public int getX() ;
public int getY() ;
public void setBrushColor(Color c) ;
public Color getBrushColor() ;
public void setBrushDown() ;
public void setBrushUp() ;
public void hide() ; // void setVisible(boolean isVisible)
public void show() ;
public void boolean isVisible() ;
\end{Verbatim}   
\end{Reponse}


\begin{Question}
  Déterminer la carte CRC pour la classe principale dénommée
  \texttt{tortue.Main}. Sachant que l'application fonctionne de la manière
  suivante.  Une fois exécutée, l'écran graphique apparaît et il est demandé à
  l'utilisateur de saisir une commande. Une fois la commande saisie, si
  celle-ci est valide, elle est exécutée et l'application demande à nouveau à
  l'utilisateur de saisir une commande.

  Les commande possibles sont les suivantes :
  
  \begin{Verbatim}[gobble=2]
  FD x    # pour faire avancer la tortue de x pixels
  BD x    # pour faire reculer la tortue de x pixels
  LT d    # pour faire tourner à gauche la tortue de d degrés
  RT d    # pour faire tourner à droite la tortue de d degrés
  PENUP   # pour lever le crayon
  PENDOWN # pour poser le crayon
  CLEAR   # pour effacer l'écran
  BC c    # pour choisir la couleur numéro c du crayon (0: blanc, 1:noir, etc)
  EXIT    # pour quitter l'application
  \end{Verbatim}
\end{Question}

\begin{Reponse}
	\begin{CRC}{}{tortue.Main}
	    \responsability{Doit instancier un nouvel écran et le conserver}
	    \responsability{Doit instancier une nouvelle tortue et la conserver}
	    \responsability{Capable de lire les commandes données par l'utilisateur}
	    \responsability{Valide les commandes saisie par l'utilisateur}
	    \responsability{Exécute les commandes valides}
	
	    \collaborator{tortue.Screen}
	    \collaborator{tortue.Tortoise}
	\end{CRC}
\end{Reponse}


\begin{Question}
Déterminer une interface publique de la classe principale de l'application.   
\end{Question}

\begin{Reponse}
\small
\begin{Verbatim}
public static void main(String args[]) ; 
\end{Verbatim}
\normalsize

Le reste n'est pas visible \texttt{;b} (mais je vous le donnerai l'an prochain
\ldots)
\end{Reponse}


\begin{Question} \emph{(facultative)} Écrivez une petite application implémentant ces classes
  \texttt{Tortue.Main} et \texttt{Tortue.Tortoise} en supposant que la classe
  \texttt{Tortue.Screen} vous est fournie.
\end{Question}
\begin{Reponse}
  C'est surtout pour occuper ceux qui s'ennuient.
\end{Reponse}

\end{Exercice}

\begin{Exercice} Spécifier les buggles de la PLM

\medskip\noindent\begin{minipage}{5cm}
\begin{center}
\includegraphics[width=5cm]{buggles.png}
\end{center}
\end{minipage}
\begin{minipage}{11cm}

Les buggles  habitent sur un monde en forme de grille. Tout comme les tortues,
elles peuvent se déplacer sur ce monde (avancer, reculer, tourner d'un quart de
tour à droite, tourner d'un quart de tour à gauche, lever une brosse, baisser une
brosse, définir la couleur d'une brosse). Le monde des buggles peut quand à lui
contenir des Baggles (les fameux biscuits tant appréciés par les buggles), mais
également des murs qui empêchent les buggles d'avancer. Les buggles doivent
donc être capables de savoir si elles sont faces à un mur ou non. De même elles
peuvent savoir si elles sont au dessus d'un baggle, le prendre et le déposer.

\end{minipage}

   
\begin{Question}
  Réaliser les différentes cartes CRC nécessaires à la conception de cette
  application. On réutilisera la carte CRC de la classe \texttt{tortue.Screen}
  vue dans l'exercice précédent.
\end{Question}

\begin{Question}
  Déterminer les interfaces publiques des classes correspondantes aux cartes
  CRC que vous avez réalisées.
\end{Question}
\end{Exercice}

* Electric Dipoles

Every electric circuit is composed of differing components such as
resistors, capacitors, diodes and electromagnetic coils. They can be
assembled in either series or parallel circuits. Depending on their
component, each circuit present a specific resistance to the current
when a voltage is applied. The *impedance* extends this notion of
resistance to alternating currents.

Given \omega the angular frequency of the current, the impedance $z$
of the circuit can be computed as follows (with the constant
$i=1\angle \frac{\pi}{2} = e^{j\frac{\pi}{2}}$).

#+BEGIN_LaTeX
\vspace{5mm}
\noindent%
\begin{tabular}[t]{m{26mm}m{100mm}c}
%\hline
\textit{Symbol}&\multicolumn{1}{c}{\textit{Description}} & \textit{Impedance} \\

\tikz \draw (0,0) to[R=$r$ in $\Omega$] (2,0); 
& A \textbf{resistor} of value  $r$ expressed in ohms (noted $\Omega$) 
& $z = r$ \\
&&\\

\tikz \draw (0,0) to[L=$l$ in H] (2,0); 
& An \textbf{inductor} of value  $l$ expressed in henries (noted $H$) 
& $z = i (\omega * l)$ \\
&&\\

\tikz \tikz \draw (0,0) to[C=$c$ in F] (2,0); 
& A \textbf{capacitor} of value  $c$ expressed in  farad (noted $F$)
& $\displaystyle  z = i ( \frac{-1}{\omega*c}) $ \\[10pt]

\setlength{\unitlength}{0.9mm}%
\begin{picture}(40,13)(0,-3)
  \put(0, 2.5){\line(1, 0){2.5}}
  % 
  \put(2.5, 0){\line(0, 0){5}}
  \put(2.5, 0){\line(1, 0){10}}
  \put(2.5, 5){\line(1, 0){10}}
  \put(12.5, 0){\line(0, 0){5}}
  % 
  \put(12.5, 2.5){\line(1, 0){5}}
  % 
  \put(17.5, 0){\line(0, 0){5}}
  \put(17.5, 0){\line(1, 0){10}}
  \put(17.5, 5){\line(1, 0){10}}
  \put(27.5, 0){\line(0, 0){5}}
  % 
  \put(27.5, 2.5){\line(1, 0){2.5}}
\end{picture}
&A \textbf{series circuit} with 2 dipoles of impedance $z_1$ and $z_2$
& $z = z_1 + z_2$ \\ 


\setlength{\unitlength}{0.9mm}%
\begin{picture}(40,13)(0,-3)
  \put(2.5, 2.5){\line(1, 0){2.5}}
  % 
  \put(5, 0){\line(0, 0){5}}
  \put(5, 0){\line(1, 0){20}}
  \put(5, 5){\line(1, 0){20}}
  \put(25, 0){\line(0, 0){5}}
  % 
  \put(25, 2.5){\line(1, 0){2.5}}
  % 
  \put(2.5, 9){\line(1, 0){2.5}}
  % 
  \put(5, 6.5){\line(0, 0){5}}
  \put(5, 6.5){\line(1, 0){20}}
  \put(5, 11.5){\line(1, 0){20}}
  \put(25, 6.5){\line(0, 0){5}}
  % 
  \put(25, 9){\line(1, 0){2.5}}
  % 
  \put(2.5, 2.5){\line(0, 0){6.5}}
  \put(27.5, 2.5){\line(0, 0){6.5}}
  \put(27.5, 6){\line(1, 0){2.5}}
  
  \put(0, 6){\line(1, 0){2.5}}
  
\end{picture}
&A \textbf{parallel circuit} with 2 dipoles of impedance $z_1$ and $z_2$
& $\displaystyle z  = \frac{1}{\frac{1}{z_1} +\frac{1}{z_2}} $ \\ 

%\hline
\end{tabular}

#+END_LaTeX
** Modeling Dipole
We will use the following class hierarchy to model the electric
dipoles.

#+BEGIN_LaTeX
\usetikzlibrary{arrows}
\tikzstyle{class}=[rectangle,draw=black!50,thick]
\tikzstyle{implements}=[dashed, -angle 45]
\tikzstyle{extends}=[-open triangle 60]

\begin{center}
  \begin{tikzpicture}
    \node [class] (dipole)     at (4,5.5)   {\textit{Dipole}}; 
    \node [class] (resistance) at (0,4)   {Resistor};
    \node [class] (capacite)   at (2,4)   {Capacitor};
    \node [class] (self)       at (4,4) {Inductor};
    \node [class] (binaire)    at (5.8,4)   {Binary$^*$};
    \node [class] (naire)      at (7.4,4)   {Nary$^*$};
    \draw [implements] (resistance.north) -- (dipole);
    \draw [implements] (capacite.north) -- (dipole);
    \draw [implements] (self.north) -- (dipole);
    \draw [implements] (binaire.north) -- (dipole);
    \draw [implements] (naire.north) -- (dipole);

    \node [class] (series)      at (4.4,3) {Series};
    \node [class] (parallele)  at (5.8,3) {Parallel};
    \node [class] (nseries)     at (7.4,3) {NSeries};
    \node [class] (nparallele) at (9.1,3) {NParallel};
    \draw [extends] (series.north) -- (binaire);
    \draw [extends] (parallele.north) -- (binaire);
    \draw [extends] (nseries.north) -- (naire);
    \draw [extends] (nparallele.north) -- (naire);
  \end{tikzpicture}
\end{center}
#+END_LaTeX

The /Dipole/ trait provides an abstract method
~impedance(omega:Double):Complex~, implemented in each concrete class
of the hierarchy. The parameter ~omega~ represents the angular
frequency of the current. The impedance is a complex number (only
resistors have a real impedance).

** Implementing Dipole
Download, unpack the [[https://github.com/mquinson/prog_scala/raw/master/Practical2/scala_exo2.tar.gz][provided code]] to your local disk and open it with
your favorite editor (or ~geany~ if you have no favorite editor
yet). The provided code contains a ~build.sbt~ file for easy
compilation, as well as a set of unit tests checking the features that
you should implement.  You should run the tests often during your
work\footnote{Run the tests with the following command: ~sbt test~} to
track your progress. Of course, the tests for a given feature will
fail until you implement that feature.

\Question We will first implement the simple dipoles. Fill the classes
~Resistor~, ~Capacitor~ and ~Inductor~ in file ~src/main/scala/~
~dipole/SimpleDipoles.scala~ to pass the first set of tests. You have
to implement both ~impedance()~ and ~toString()~.

#+BEGIN_LaTeX
\begin{figure}[h]
  \centering
  \begin{minipage}[b]{.3\linewidth}
    \centerline{\tikz \draw (0,0) to[L=$7\times 10^{-2}H$] (2,0);} \par

    \bigskip
    \centerline{($z\approx 22j~ \Omega$)}

    \caption{Tested Inductor.}
  \end{minipage}
  \begin{minipage}[b]{.3\linewidth}
    \centerline{\tikz \draw (0,0) to[C=$42F$] (2,0);} \par

    \smallskip
    \centerline{($z\approx -7.6\times 10^{-5} j~ \Omega$)}

    \caption{Tested Capacitor.}\label{fig:capa}
  \end{minipage}
  \begin{minipage}[b]{.34\linewidth}
    \centerline{\tikz \draw (0,0) to[R=$100\Omega$] (2,0);} \par

    \bigskip
    \centerline{($z = 100~ \Omega$)}

    \caption{Tested Resistor.}\label{fig:capa}
  \end{minipage}
\end{figure}
#+END_LaTeX

\Question We will now implement the binary circuits, either built in
parallel or in series. Check your implementation with the provided
tests, that use the following circuits.

#+BEGIN_LaTeX
\begin{figure}[h]
  \centering
  \begin{minipage}[b]{.4\linewidth}
    \centerline{\tikz \draw (0,0) to [L=$5\times 10^{-2}H$] %
                        (2,0) to [R=$10^2\Omega$] %
                        (4,0) ;} \par
    \vspace{3.4\baselineskip}
                      
    \centerline{($z\approx 100.0 + 15.70j~ \Omega$)}
    \caption{Tested Series Circuit.}\label{fig:series}                     
  \end{minipage}~
  \begin{minipage}[b]{.4\linewidth}
    \begin{center}
      \begin{circuitikz}
        % Interne
        \draw (0.5,1.7) to [L=$5\times 10^{-5}H$] (3.5,1.7);
        \draw (0.5,3)   to [R=$10^2\Omega$]      (3.5,3);
        \draw (3.5,3) -- (3.5,1.7);
        \draw (0.5,3) -- (0.5,1.7);
        % Englobant
        \draw (0,0)     to [C=$9\times 10^{-4}F$] (4,0);
        \draw (4,0) -- (4,2.4) -- (3.5,2.4);
        \draw (0,0) -- (0,2.4) -- (0.5,2.4);
        % externe
        \draw (-0.5,1.2) to[short,o-] (0,1.2);
        \draw  (4,1.2) to[short,-o] (4.5,1.2);
      \end{circuitikz}
    \end{center}

    \centerline{($z \approx 0.2079 + -4.55j~ \Omega$)}
    
    \caption{Tested Parallel Circuit.}\label{fig:para}
  \end{minipage}
\end{figure}

#+END_LaTeX


\Question We will now implement N-ary circuits. The impedance of a series
circuit is simply given by $\displaystyle \sum_{i=1}^{n}\omega_i$ while the
impedance of a parallel circuit is given by
$\displaystyle\frac{1}{\displaystyle\sum_{i=1}^{n}\frac{1}{\omega_i}}$. 

Note that you also have to implement a ~Nary.::(head:Dipole)~ method,
enabling to build a new circuit by appending a dipole to the currently
defined one.

\Question You will now fill the file
~src/main/scala/dipole/Instances.scala~ to define the instances of
dipoles depicted below.

#+BEGIN_LaTeX
\begin{figure}[h]
  \centering

  \begin{minipage}{.4\linewidth}
    \begin{circuitikz}
      % Interne
      \draw (0.5,1.7) to [L=$5\times 10^{-5}H$] (2.5,1.7)
                      to [R=$12\times 10^3\Omega$] (4.5,1.7);
      \draw (0.5,3)   to [R=$10^2\Omega$]      (4.5,3);
      \draw (4.5,3) -- (4.5,1.7);
      \draw (0.5,3) -- (0.5,1.7);
      % Englobant
      \draw (0,0)     to [C=$9\times 10^{-4}F$] (5,0);
      \draw (5,0) -- (5,2.4) -- (4.5,2.4);
      \draw (0,0) -- (0,2.4) -- (0.5,2.4);
      % externe
      \draw (-0.5,1.2) to[short,o-] (0,1.2);
      \draw  (5,1.2) to[short,-o] (5.5,1.2);
    \end{circuitikz}
    \caption{The  \texttt{dip1} dipole.}\label{fig:dip1}
  \end{minipage}\hfill%
  \begin{minipage}{.5\linewidth}
    \begin{tikzpicture}[scale=.8]
      \draw (0.5,3) to[R=$100\Omega$] (1.5,3); % Le premier à gauche
      \draw (1.5,3) -- (2.5,3) -- (2.5,1.5) -- (2.5,4.5); % gauche-milieu
      \draw (6,4.5) -- (6,1.5) -- (6,3) -- (6.5,3); % milieu-droite
      \draw (1.9,3) -- (1.9,0) -- (2,0); %milieu-bas par la gauche
      \draw (7.5,0) -- (8,0) -- (8,3); %milieu-bas par la droite
      \draw (7.5,3) -- (8.5,3); % droite-extreme droite
      % ligne du bas
      \draw (2,0) to [R=$1000\Omega$] (5,0) to [L=$2\times 10^{-1}$H] (7.5,0);
      % A l'intérieur
        % ligne du haut
        \draw (2.5,4.5) to [R=$10^3\Omega$]     (4.5,4.5)
                        to [L=$5\times 10^{-2}$] (6,4.5);
        % ligne du milieu
        \draw (2.5,3) to [C=$9\times 10^{-3}$] (6,3);
        % ligne du bas
        \draw (2.5,1.5) to [C=$9\times 10^{-4}$] (4.5,1.5) 
                        to [C=$10^{-5}$]         (6,1.5);
      % à droite au centre
      \draw (6.5,3) to [R=$330\Omega$] (7.5,3);

      % à l'extrême droite 
      \draw (8.5,3) to [C=$10^{-6}$] (9.5,3);
                        
      % Les connecteurs au monde extérieur
      \draw (0,3) to[short,o-] (0.5,3);
      \draw (9.5,3) to[short,-o] (10,3);
    \end{tikzpicture}
    \caption{The \texttt{dip2}  dipole.}\label{fig:dip2}
  \end{minipage}
\end{figure}
#+END_LaTeX

* Blogging 
#+LaTeX: \setcounter{Question}{0}
#+LaTeX: \newcommand{\meth}[1]{\fbox{\texttt{#1}}}
We will now implement a blogging micro-system: a web site constituted
of posts aggregated over time. These posts can be text messages,
images or videos.  \emph{Tags} can be attached to images or videos, to
select the ones that match a given set of keywords. The textual
messages cannot be tagged, but the textual search should operate on
their content directly.

#+BEGIN_LaTeX
\begin{figure}[htb]
\noindent%
\resizebox{\linewidth}{!}{
\begin{tikzpicture}[]%[show background grid]
  \begin{class}[text width=5cm]{case Publishable}{3.5,-4.5}
    \attribute{date:Long}
    \attribute{author:String}
  \end{class}

  \begin{interface}[text width=4.5cm]{Taggable}{-2.5,-2.5}
         \attribute{tags: List[String]}
	 \operation{addTag(tag:String)}
	 \operation{removeTag(tag:String)}
	 \operation{tagCount() :Integer)}
	 \operation{getTags() :List[String]}
  \end{interface}

  \begin{class}[text width=3cm]{Message}{5.5,-7.5}
	 \inherit{case Publishable}
	 \attribute{content:String}
  \end{class}

  \begin{class}[text width=3cm]{Picture}{1.5,-7.5}
	 \inherit{case Publishable}
	 \implement{Taggable}
	 \attribute{url: String}
  \end{class}

  \begin{class}[text width=3cm]{Video}{-2.5,-7.5}
	 \inherit{case Publishable}
	 \implement{Taggable}
	 \attribute{url: String}
  \end{class}

  \begin{class}[text width=10cm]{BlogService}{13.5,-2.6}
    \attribute{title :String}
    \operation{post(item:Publishable)}
    \operation{getItems() :List[Publishable]}
    \operation{getPublishableItemsCount() :Integer}
    \operation{getTaggableItemsCount() :Integer}
    \operation{getLatestItem(): Publishable }
    \operation{find(filter: Publishable => Boolean): List[Publishable]}
    \operation{byTags(tags:List[String]) :List[Publishable]}
    \operation{byContent(keywords:List[String]) :List[Publishable]}
    \operation{byTagsOrContent(words:List[String]) :List[Publishable]}
  \end{class}

  \aggregation{BlogService}{items}{0..*}{case Publishable}
\end{tikzpicture}
}
\end{figure}
#+END_LaTeX

\Question Implement this hierarchy of classes, and test your work with
an appropriate specification.
